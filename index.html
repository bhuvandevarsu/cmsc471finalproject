<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lloyd’s k-Means on an Albers USA Map</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
    }
    svg {
      border: 1px solid #ccc;
      margin-top: 10px;
      background: #fafafa;
    }
    .point { opacity: 0.6; }
    .centroid {
      stroke: #000;
      stroke-width: 2px;
    }
    button, input {
      margin: 0 5px;
      padding: 5px 10px;
      font-size: 1rem;
    }
  </style>
</head>
<body>
  <h1>Lloyd’s k-Means on an Albers USA Map</h1>
  <label for="k">k = </label>
  <input type="number" id="k" value="5" min="1" max="15" />
  <button id="reset">Reset</button>
  <button id="next">Next Iteration</button>

  <svg width="800" height="600"></svg>

  <script>
    d3.csv("data/public_schools_short.csv", d => ({
      lon: +d.LON,
      lat: +d.LAT
    })).then(rawData => {
      const width = 800,
            height = 600,
            svg = d3.select("svg"),
            kInput = d3.select("#k"),
            resetBtn = d3.select("#reset"),
            nextBtn = d3.select("#next");
      
      const projection = d3.geoAlbersUsa()
                           .translate([width/2, height/2])
                           .scale(1000);

      const data = rawData
        .map(d => {
          const xy = projection([d.lon, d.lat]);
          if (!xy) return null;
          return { x: xy[0], y: xy[1] };
        })
        .filter(d => d);

      let centroids;

      function init() {
        const k = +kInput.property("value");
        centroids = d3.shuffle(data)
                      .slice(0, k)
                      .map(d => ({ x: d.x, y: d.y }));
        step();
      }

      function step() {
        data.forEach(p => {
          let best = 0, bestDist = Infinity;
          centroids.forEach((c, i) => {
            const dx = p.x - c.x,
                  dy = p.y - c.y,
                  dist = dx*dx + dy*dy;
            if (dist < bestDist) {
              bestDist = dist;
              best = i;
            }
          });
          p.cluster = best;
        });

        centroids = centroids.map((c,i) => {
          const members = data.filter(p => p.cluster === i);
          return {
            x: d3.mean(members, p => p.x),
            y: d3.mean(members, p => p.y)
          };
        });

        draw();
      }

      function draw() {
        const color = d3.schemeCategory10;

        svg.selectAll("circle.point")
           .data(data)
           .join("circle")
           .attr("class","point")
           .attr("r",3)
           .attr("cx", d=>d.x)
           .attr("cy", d=>d.y)
           .attr("fill", d=>color[d.cluster]);

        svg.selectAll("circle.centroid")
           .data(centroids)
           .join("circle")
           .attr("class","centroid")
           .attr("r",8)
           .attr("cx", d=>d.x)
           .attr("cy", d=>d.y)
           .attr("fill", (_,i)=>color[i]);
      }

      resetBtn.on("click", init);
      nextBtn.on("click", step);
      
      init();
    });
  </script>
</body>
</html>